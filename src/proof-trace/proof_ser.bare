
type ID i32
type Lit ID

type Clause {
  lits: []Lit
}

type Step_input {
  c: Clause
}

# clause, RUP with previous steps
type Step_rup {
  res: Clause
  hyps: []ID
}

# TODO: remove?
# lit <-> expr
type Step_bridge_lit_expr {
  lit: Lit
  expr: ID
}

# prove congruence closure lemma `\/_{e\in eqns} e`
type Step_cc {
  eqns: []ID
}

# prove t=u using some previous steps and unit equations,
# and add clause (t=u) with given ID
type Step_preprocess {
  t: ID
  u: ID
  using: []ID
}

type Fun_decl {
  f: string
}

type Expr_bool {
  b: bool
}

type Expr_if {
  cond: ID
  then_: ID
  else_: ID
}

type Expr_not {
  f: ID
}

type Expr_eq {
  lhs: ID
  rhs: ID
}

type Expr_app {
  f: ID
  args: []ID
}

type Step_view
  ( Step_input
  | Step_rup
  | Step_bridge_lit_expr
  | Step_cc
  | Step_preprocess
  | Fun_decl
  | Expr_bool
  | Expr_if
  | Expr_not
  | Expr_eq
  | Expr_app
  )

type Step {
  id: ID
  view: Step_view
}


