<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sidekick_base__Proof (sidekick-base.Sidekick_base__Proof)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">sidekick-base</a> &#x00BB; Sidekick_base__Proof</nav><h1>Module <code>Sidekick_base__Proof</code></h1><p>Proofs of unsatisfiability</p><p>Proofs are used in sidekick when the problem is found <b>unsatisfiable</b>. A proof collects inferences made by the solver into a list of steps, each with its own kind of justification (e.g. &quot;by congruence&quot;), and outputs it in some kind of format.</p><p>Currently we target <a href="https://c-cube.github.io/quip-book/">Quip</a> as an experimental proof backend.</p></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../sidekick/Sidekick_core/index.html#module-type-PROOF">Sidekick_core.PROOF</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../sidekick/Sidekick_core/module-type-PROOF/index.html#type-term">term</a> = <a href="../Sidekick_base/Base_types/Term/index.html#type-t">Sidekick_base.Base_types.Term.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../../sidekick/Sidekick_core/module-type-PROOF/index.html#type-ty">ty</a> = <a href="../Sidekick_base/Base_types/Ty/index.html#type-t">Sidekick_base.Base_types.Ty.t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The abstract representation of a proof. A proof always proves a clause to be <b>valid</b> (true in every possible interpretation of the problem's assertions, and the theories)</p></dd></dl><dl><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type</span> term</code><code> = <a href="../Sidekick_base/Base_types/Term/index.html#type-t">Sidekick_base.Base_types.Term.t</a></code></dt><dt class="spec type" id="type-ty"><a href="#type-ty" class="anchor"></a><code><span class="keyword">type</span> ty</code><code> = <a href="../Sidekick_base/Base_types/Ty/index.html#type-t">Sidekick_base.Base_types.Ty.t</a></code></dt><dt class="spec type" id="type-hres_step"><a href="#type-hres_step" class="anchor"></a><code><span class="keyword">type</span> hres_step</code></dt><dd><p>hyper-resolution steps: resolution, unit resolution; bool paramodulation, unit bool paramodulation</p></dd></dl><dl><dt class="spec value" id="val-r"><a href="#val-r" class="anchor"></a><code><span class="keyword">val</span> r : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>pivot:<a href="index.html#type-term">term</a></span> <span>&#45;&gt;</span> <a href="index.html#type-hres_step">hres_step</a></code></dt><dd><p>Resolution step on given pivot term</p></dd></dl><dl><dt class="spec value" id="val-r1"><a href="#val-r1" class="anchor"></a><code><span class="keyword">val</span> r1 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-hres_step">hres_step</a></code></dt><dd><p>Unit resolution; pivot is obvious</p></dd></dl><dl><dt class="spec value" id="val-p"><a href="#val-p" class="anchor"></a><code><span class="keyword">val</span> p : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>lhs:<a href="index.html#type-term">term</a></span> <span>&#45;&gt;</span> <span>rhs:<a href="index.html#type-term">term</a></span> <span>&#45;&gt;</span> <a href="index.html#type-hres_step">hres_step</a></code></dt><dd><p>Paramodulation using proof whose conclusion has a literal <code>lhs=rhs</code></p></dd></dl><dl><dt class="spec value" id="val-p1"><a href="#val-p1" class="anchor"></a><code><span class="keyword">val</span> p1 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-hres_step">hres_step</a></code></dt><dd><p>Unit paramodulation</p></dd></dl><dl><dt class="spec type" id="type-lit"><a href="#type-lit" class="anchor"></a><code><span class="keyword">type</span> lit</code></dt><dd><p>Proof representation of literals</p></dd></dl><dl><dt class="spec value" id="val-pp_lit"><a href="#val-pp_lit" class="anchor"></a><code><span class="keyword">val</span> pp_lit : <span><a href="index.html#type-lit">lit</a> <a href="../../sidekick/Sidekick_core/index.html#module-Fmt">Sidekick_core.Fmt</a>.printer</span></code></dt><dt class="spec value" id="val-lit_a"><a href="#val-lit_a" class="anchor"></a><code><span class="keyword">val</span> lit_a : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a></code></dt><dt class="spec value" id="val-lit_na"><a href="#val-lit_na" class="anchor"></a><code><span class="keyword">val</span> lit_na : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a></code></dt><dt class="spec value" id="val-lit_mk"><a href="#val-lit_mk" class="anchor"></a><code><span class="keyword">val</span> lit_mk : bool <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a></code></dt><dt class="spec value" id="val-lit_eq"><a href="#val-lit_eq" class="anchor"></a><code><span class="keyword">val</span> lit_eq : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a></code></dt><dt class="spec value" id="val-lit_neq"><a href="#val-lit_neq" class="anchor"></a><code><span class="keyword">val</span> lit_neq : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a></code></dt><dt class="spec value" id="val-lit_not"><a href="#val-lit_not" class="anchor"></a><code><span class="keyword">val</span> lit_not : <a href="index.html#type-lit">lit</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a></code></dt><dt class="spec value" id="val-lit_sign"><a href="#val-lit_sign" class="anchor"></a><code><span class="keyword">val</span> lit_sign : <a href="index.html#type-lit">lit</a> <span>&#45;&gt;</span> bool</code></dt></dl><dl><dt class="spec type" id="type-composite_step"><a href="#type-composite_step" class="anchor"></a><code><span class="keyword">type</span> composite_step</code></dt></dl><dl><dt class="spec value" id="val-stepc"><a href="#val-stepc" class="anchor"></a><code><span class="keyword">val</span> stepc : <span>name:string</span> <span>&#45;&gt;</span> <span><a href="index.html#type-lit">lit</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-composite_step">composite_step</a></code></dt><dt class="spec value" id="val-deft"><a href="#val-deft" class="anchor"></a><code><span class="keyword">val</span> deft : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-composite_step">composite_step</a></code></dt><dd><p>define a (new) atomic term</p></dd></dl><dl><dt class="spec value" id="val-is_trivial_refl"><a href="#val-is_trivial_refl" class="anchor"></a><code><span class="keyword">val</span> is_trivial_refl : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>is this a proof of <code>|- t=t</code>? This can be used to remove some trivial steps that would build on the proof (e.g. rewriting using <code>refl t</code> is useless).</p></dd></dl><dl><dt class="spec value" id="val-assertion"><a href="#val-assertion" class="anchor"></a><code><span class="keyword">val</span> assertion : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-assertion_c"><a href="#val-assertion_c" class="anchor"></a><code><span class="keyword">val</span> assertion_c : <span><a href="index.html#type-lit">lit</a> Iter.t</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-ref_by_name"><a href="#val-ref_by_name" class="anchor"></a><code><span class="keyword">val</span> ref_by_name : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-assertion_c_l"><a href="#val-assertion_c_l" class="anchor"></a><code><span class="keyword">val</span> assertion_c_l : <span><a href="index.html#type-lit">lit</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-hres_iter"><a href="#val-hres_iter" class="anchor"></a><code><span class="keyword">val</span> hres_iter : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-hres_step">hres_step</a> Iter.t</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-hres_l"><a href="#val-hres_l" class="anchor"></a><code><span class="keyword">val</span> hres_l : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-hres_step">hres_step</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-res"><a href="#val-res" class="anchor"></a><code><span class="keyword">val</span> res : <span>pivot:<a href="index.html#type-term">term</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-res1"><a href="#val-res1" class="anchor"></a><code><span class="keyword">val</span> res1 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-refl"><a href="#val-refl" class="anchor"></a><code><span class="keyword">val</span> refl : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-true_is_true"><a href="#val-true_is_true" class="anchor"></a><code><span class="keyword">val</span> true_is_true : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-true_neq_false"><a href="#val-true_neq_false" class="anchor"></a><code><span class="keyword">val</span> true_neq_false : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-nn"><a href="#val-nn" class="anchor"></a><code><span class="keyword">val</span> nn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-cc_lemma"><a href="#val-cc_lemma" class="anchor"></a><code><span class="keyword">val</span> cc_lemma : <span><a href="index.html#type-lit">lit</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-cc_imply2"><a href="#val-cc_imply2" class="anchor"></a><code><span class="keyword">val</span> cc_imply2 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-cc_imply_l"><a href="#val-cc_imply_l" class="anchor"></a><code><span class="keyword">val</span> cc_imply_l : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-composite_iter"><a href="#val-composite_iter" class="anchor"></a><code><span class="keyword">val</span> composite_iter : <span>?&#8288;assms:<span><span>(string * <a href="index.html#type-lit">lit</a>)</span> list</span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-composite_step">composite_step</a> Iter.t</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-composite_l"><a href="#val-composite_l" class="anchor"></a><code><span class="keyword">val</span> composite_l : <span>?&#8288;assms:<span><span>(string * <a href="index.html#type-lit">lit</a>)</span> list</span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-composite_step">composite_step</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-sorry"><a href="#val-sorry" class="anchor"></a><code><span class="keyword">val</span> sorry : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-sorry_c"><a href="#val-sorry_c" class="anchor"></a><code><span class="keyword">val</span> sorry_c : <span><a href="index.html#type-lit">lit</a> Iter.t</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-sorry_c_l"><a href="#val-sorry_c_l" class="anchor"></a><code><span class="keyword">val</span> sorry_c_l : <span><a href="index.html#type-lit">lit</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-default"><a href="#val-default" class="anchor"></a><code><span class="keyword">val</span> default : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-pp_debug"><a href="#val-pp_debug" class="anchor"></a><code><span class="keyword">val</span> pp_debug : <span>sharing:bool</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> <a href="../../sidekick/Sidekick_core/index.html#module-Fmt">Sidekick_core.Fmt</a>.printer</span></code></dt><dd><p>Pretty print a proof.</p><dl><dt>parameter sharing</dt><dd><p>if true, try to compact the proof by introducing definitions for common terms, clauses, and steps as needed. Safe to ignore.</p></dd></dl></dd></dl><div class="spec module" id="module-Quip"><a href="#module-Quip" class="anchor"></a><code><span class="keyword">module</span> <a href="Quip/index.html">Quip</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div><dl><dt class="spec value" id="val-isa_split"><a href="#val-isa_split" class="anchor"></a><code><span class="keyword">val</span> isa_split : <a href="index.html#type-ty">ty</a> <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> Iter.t</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-isa_disj"><a href="#val-isa_disj" class="anchor"></a><code><span class="keyword">val</span> isa_disj : <a href="index.html#type-ty">ty</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-cstor_inj"><a href="#val-cstor_inj" class="anchor"></a><code><span class="keyword">val</span> cstor_inj : <a href="../Sidekick_base/Base_types/Cstor/index.html#type-t">Sidekick_base.Base_types.Cstor.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-bool_eq"><a href="#val-bool_eq" class="anchor"></a><code><span class="keyword">val</span> bool_eq : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-bool_c"><a href="#val-bool_c" class="anchor"></a><code><span class="keyword">val</span> bool_c : string <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-ite_true"><a href="#val-ite_true" class="anchor"></a><code><span class="keyword">val</span> ite_true : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-ite_false"><a href="#val-ite_false" class="anchor"></a><code><span class="keyword">val</span> ite_false : <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-lra"><a href="#val-lra" class="anchor"></a><code><span class="keyword">val</span> lra : <span><a href="index.html#type-lit">lit</a> Iter.t</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-lra_l"><a href="#val-lra_l" class="anchor"></a><code><span class="keyword">val</span> lra_l : <span><a href="index.html#type-lit">lit</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl></div></body></html>