<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>THEORY (sidekick.Sidekick_msat_solver.Make.THEORY)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">sidekick</a> &#x00BB; <a href="../../index.html">Sidekick_msat_solver</a> &#x00BB; <a href="../index.html">Make</a> &#x00BB; THEORY</nav><h1>Module type <code>Make.THEORY</code></h1><h4 id="a-theory"><a href="#a-theory" class="anchor"></a>A theory</h4><p>Theories are abstracted over the concrete implementation of the solver, so they can work with any implementation.</p><p>Typically a theory should be a functor taking an argument containing a <code>SOLVER_INTERNAL</code> or even a full <code>SOLVER</code>, and some additional views on terms, literals, etc. that are specific to the theory (e.g. to map terms to linear expressions). The theory can then be instantiated on any kind of solver for any term representation that also satisfies the additional theory-specific requirements. Instantiated theories (ie values of type <a href="../../../Sidekick_core/module-type-SOLVER/index.html#type-theory"><code>Sidekick_core.SOLVER.theory</code></a>) can be added to the solver.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The theory's state</p></dd></dl><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val</span> name : string</code></dt><dd><p>Name of the theory (ideally, unique and short)</p></dd></dl><dl><dt class="spec value" id="val-create_and_setup"><a href="#val-create_and_setup" class="anchor"></a><code><span class="keyword">val</span> create_and_setup : <a href="../Solver_internal/index.html#type-t">Solver_internal.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Instantiate the theory's state for the given (internal) solver, register callbacks, create keys, etc.</p><p>Called once for every solver this theory is added to.</p></dd></dl><dl><dt class="spec value" id="val-push_level"><a href="#val-push_level" class="anchor"></a><code><span class="keyword">val</span> push_level : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Push backtracking level. When the corresponding pop is called, the theory's state should be restored to a state <b>equivalent</b> to what it was just before <code>push_level</code>.</p><p>it does not have to be exactly the same state, it just needs to be equivalent.</p></dd></dl><dl><dt class="spec value" id="val-pop_levels"><a href="#val-pop_levels" class="anchor"></a><code><span class="keyword">val</span> pop_levels : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pop_levels theory n</code> pops <code>n</code> backtracking levels, restoring <code>theory</code> to its state before calling <code>push_level</code> n times.</p></dd></dl></div></body></html>