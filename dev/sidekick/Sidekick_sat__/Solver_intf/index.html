<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Solver_intf (sidekick.Sidekick_sat__.Solver_intf)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">sidekick</a> &#x00BB; <a href="../index.html">Sidekick_sat__</a> &#x00BB; Solver_intf</nav><h1>Module <code>Sidekick_sat__.Solver_intf</code></h1></header><aside><p>Interface for Solvers</p><p>This modules defines the safe external interface for solvers. Solvers that implements this interface can be obtained using the <code>Make</code> functor in <a href="../Solver/index.html"><code>Solver</code></a> or <code>Mcsolver</code>.</p></aside><dl><dt class="spec type" id="type-printer"><a href="#type-printer" class="anchor"></a><code><span class="keyword">type</span> <span>'a printer</span></code><code> = Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt></dl><div class="spec module-type" id="module-type-SAT_STATE"><a href="#module-type-SAT_STATE" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SAT_STATE/index.html">SAT_STATE</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-sat_state"><a href="#type-sat_state" class="anchor"></a><code><span class="keyword">type</span> <span>'form sat_state</span></code><code> = <span>(<span class="keyword">module</span> <a href="module-type-SAT_STATE/index.html">SAT_STATE</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-SAT_STATE/index.html#type-lit">lit</a> = <span class="type-var">'form</span>)</span></code></dt><dd><p>The type of values returned when the solver reaches a SAT state.</p></dd></dl><div class="spec module-type" id="module-type-UNSAT_STATE"><a href="#module-type-UNSAT_STATE" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-UNSAT_STATE/index.html">UNSAT_STATE</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-unsat_state"><a href="#type-unsat_state" class="anchor"></a><code><span class="keyword">type</span> <span>('lit, 'clause) unsat_state</span></code><code> = <span>(<span class="keyword">module</span> <a href="module-type-UNSAT_STATE/index.html">UNSAT_STATE</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-UNSAT_STATE/index.html#type-clause">clause</a> = <span class="type-var">'clause</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-UNSAT_STATE/index.html#type-lit">lit</a> = <span class="type-var">'lit</span>)</span></code></dt><dd><p>The type of values returned when the solver reaches an UNSAT state.</p></dd></dl><dl><dt class="spec type" id="type-same_sign"><a href="#type-same_sign" class="anchor"></a><code><span class="keyword">type</span> same_sign</code><code> = bool</code></dt><dd><p>This type is used during the normalisation of lits. <code>true</code> means the literal stayed the same, <code>false</code> that its sign was flipped.</p></dd></dl><dl><dt class="spec type" id="type-reason"><a href="#type-reason" class="anchor"></a><code><span class="keyword">type</span> <span>('lit, 'proof) reason</span></code><code> = </code><table class="variant"><tr id="type-reason.Consequence" class="anchored"><td class="def constructor"><a href="#type-reason.Consequence" class="anchor"></a><code>| </code><code><span class="constructor">Consequence</span> <span class="keyword">of</span> unit <span>&#45;&gt;</span> <span><span class="type-var">'lit</span> list</span> * <span class="type-var">'proof</span></code></td></tr></table></dt><dd><p>The type of reasons for propagations of a lit <code>f</code>.</p><p><code>Consequence (l, p)</code> means that the lits in <code>l</code> imply the propagated lit <code>f</code>. The proof should be a proof of the clause &quot;<code>l</code> implies <code>f</code>&quot;.</p><p>invariant: in <code>Consequence (fun () -&gt; l,p)</code>, all elements of <code>l</code> must be true in the current trail.</p><p><b>note</b> on lazyiness: the justification is suspended (using <code>unit -&gt; …</code>) to avoid potentially costly computations that might never be used if this literal is backtracked without participating in a conflict. Therefore the function that produces <code>(l,p)</code> needs only be safe in trails (partial models) that are conservative extensions of the current trail. If the theory isn't robust w.r.t. extensions of the trail (e.g. if its internal state undergoes significant changes), it can be easier to produce the explanation eagerly when propagating, and then use <code>Consequence (fun () -&gt; expl, proof)</code> with the already produced <code>(expl,proof)</code> tuple.</p></dd></dl><dl><dt class="spec type" id="type-lbool"><a href="#type-lbool" class="anchor"></a><code><span class="keyword">type</span> lbool</code><code> = </code><table class="variant"><tr id="type-lbool.L_true" class="anchored"><td class="def constructor"><a href="#type-lbool.L_true" class="anchor"></a><code>| </code><code><span class="constructor">L_true</span></code></td></tr><tr id="type-lbool.L_false" class="anchored"><td class="def constructor"><a href="#type-lbool.L_false" class="anchor"></a><code>| </code><code><span class="constructor">L_false</span></code></td></tr><tr id="type-lbool.L_undefined" class="anchored"><td class="def constructor"><a href="#type-lbool.L_undefined" class="anchor"></a><code>| </code><code><span class="constructor">L_undefined</span></code></td><td class="doc"><p>Valuation of an atom</p></td></tr></table></dt></dl><div class="spec module" id="module-Clause_pool_id"><a href="#module-Clause_pool_id" class="anchor"></a><code><span class="keyword">module</span> <a href="Clause_pool_id/index.html">Clause_pool_id</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module-type" id="module-type-ACTS"><a href="#module-type-ACTS" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-ACTS/index.html">ACTS</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Actions available to the Plugin</p></dd></dl><dl><dt class="spec type" id="type-acts"><a href="#type-acts" class="anchor"></a><code><span class="keyword">type</span> <span>('lit, 'proof) acts</span></code><code> = <span>(<span class="keyword">module</span> <a href="module-type-ACTS/index.html">ACTS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-ACTS/index.html#type-lit">lit</a> = <span class="type-var">'lit</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-ACTS/index.html#type-proof">proof</a> = <span class="type-var">'proof</span>)</span></code></dt><dd><p>The type for a slice of assertions to assume/propagate in the theory.</p></dd></dl><dl><dt class="spec exception" id="exception-No_proof"><a href="#exception-No_proof" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">No_proof</span></code></dt></dl><div class="spec module-type" id="module-type-LIT"><a href="#module-type-LIT" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-LIT/index.html">LIT</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module-type" id="module-type-PROOF"><a href="#module-type-PROOF" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-PROOF/index.html">PROOF</a> = <a href="../../Sidekick_core/index.html#module-type-SAT_PROOF">Sidekick_core.SAT_PROOF</a></code></div><dl><dt class="spec module-type" id="module-type-PLUGIN_CDCL_T"><a href="#module-type-PLUGIN_CDCL_T" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-PLUGIN_CDCL_T/index.html">PLUGIN_CDCL_T</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Signature for theories to be given to the CDCL(T) solver</p></dd></dl><dl><dt class="spec module-type" id="module-type-PLUGIN_SAT"><a href="#module-type-PLUGIN_SAT" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-PLUGIN_SAT/index.html">PLUGIN_SAT</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Signature for pure SAT solvers</p></dd></dl><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The external interface implemented by safe solvers, such as the one created by the <span class="xref-unresolved" title="unresolved reference to &quot;Solver.Make&quot;"><a href="../index.html#module-Solver"><code>Solver</code></a>.Make</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Mcsolver.Make&quot;"><code>Mcsolver</code>.Make</span> functors.</p></dd></dl></div></body></html>