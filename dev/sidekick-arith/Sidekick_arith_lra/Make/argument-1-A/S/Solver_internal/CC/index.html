<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CC (sidekick-arith.Sidekick_arith_lra.Make.1-A.S.Solver_internal.CC)</title><link rel="stylesheet" href="../../../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../../../../index.html">sidekick-arith</a> &#x00BB; <a href="../../../../../index.html">Sidekick_arith_lra</a> &#x00BB; <a href="../../../../index.html">Make</a> &#x00BB; <a href="../../../index.html">1-A</a> &#x00BB; <a href="../../index.html">S</a> &#x00BB; <a href="../index.html">Solver_internal</a> &#x00BB; CC</nav><h1>Module <code>Solver_internal.CC</code></h1><p>Congruence closure instance</p><nav class="toc"><ul><li><a href="#accessors">Accessors</a></li><li><a href="#events">Events</a></li></ul></nav></header><div class="spec module" id="module-T"><a href="#module-T" class="anchor"></a><code><span class="keyword">module</span> T = <a href="../index.html#module-T">T</a></code></div><div class="spec module" id="module-P"><a href="#module-P" class="anchor"></a><code><span class="keyword">module</span> P = <a href="../index.html#module-P">P</a></code></div><div class="spec module" id="module-Lit"><a href="#module-Lit" class="anchor"></a><code><span class="keyword">module</span> Lit = <a href="../index.html#module-Lit">Lit</a></code></div><div class="spec module" id="module-Actions"><a href="#module-Actions" class="anchor"></a><code><span class="keyword">module</span> <a href="Actions/index.html">Actions</a> : <a href="../../../../../../../sidekick/Sidekick_core/index.html#module-type-CC_ACTIONS">Sidekick_core.CC_ACTIONS</a> <span class="keyword">with</span> <span class="keyword">module</span> <a href="../../../../../../../sidekick/Sidekick_core/module-type-CC_ACTIONS/T/index.html">T</a> = <a href="index.html#module-T">T</a> <span class="keyword">and</span> <span class="keyword">module</span> <a href="../../../../../../../sidekick/Sidekick_core/module-type-CC_ACTIONS/Lit/index.html">Lit</a> = <a href="index.html#module-Lit">Lit</a> <span class="keyword">and</span> <span class="keyword">module</span> <a href="../../../../../../../sidekick/Sidekick_core/module-type-CC_ACTIONS/P/index.html">P</a> = <a href="index.html#module-P">P</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="../../../../../../../sidekick/Sidekick_core/module-type-CC_ACTIONS/index.html#type-t">t</a> = <a href="../index.html#type-actions">actions</a></code></div><dl><dt class="spec type" id="type-term_state"><a href="#type-term_state" class="anchor"></a><code><span class="keyword">type</span> term_state</code><code> = <a href="T/Term/index.html#type-state">T.Term.state</a></code></dt><dt class="spec type" id="type-term"><a href="#type-term" class="anchor"></a><code><span class="keyword">type</span> term</code><code> = <a href="T/Term/index.html#type-t">T.Term.t</a></code></dt><dt class="spec type" id="type-fun_"><a href="#type-fun_" class="anchor"></a><code><span class="keyword">type</span> fun_</code><code> = <a href="T/Fun/index.html#type-t">T.Fun.t</a></code></dt><dt class="spec type" id="type-lit"><a href="#type-lit" class="anchor"></a><code><span class="keyword">type</span> lit</code><code> = <a href="Lit/index.html#type-t">Lit.t</a></code></dt><dt class="spec type" id="type-proof"><a href="#type-proof" class="anchor"></a><code><span class="keyword">type</span> proof</code><code> = <a href="P/index.html#type-t">P.t</a></code></dt><dt class="spec type" id="type-actions"><a href="#type-actions" class="anchor"></a><code><span class="keyword">type</span> actions</code><code> = <a href="Actions/index.html#type-t">Actions.t</a></code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>State of the congruence closure</p></dd></dl><dl><dt class="spec module" id="module-N"><a href="#module-N" class="anchor"></a><code><span class="keyword">module</span> <a href="N/index.html">N</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>An equivalence class is a set of terms that are currently equal in the partial model built by the solver. The class is represented by a collection of nodes, one of which is distinguished and is called the &quot;representative&quot;.</p></dd></dl><dl><dt class="spec module" id="module-Expl"><a href="#module-Expl" class="anchor"></a><code><span class="keyword">module</span> <a href="Expl/index.html">Expl</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Explanations</p></dd></dl><dl><dt class="spec type" id="type-node"><a href="#type-node" class="anchor"></a><code><span class="keyword">type</span> node</code><code> = <a href="N/index.html#type-t">N.t</a></code></dt><dd><p>A node of the congruence closure</p></dd></dl><dl><dt class="spec type" id="type-repr"><a href="#type-repr" class="anchor"></a><code><span class="keyword">type</span> repr</code><code> = <a href="N/index.html#type-t">N.t</a></code></dt><dd><p>Node that is currently a representative</p></dd></dl><dl><dt class="spec type" id="type-explanation"><a href="#type-explanation" class="anchor"></a><code><span class="keyword">type</span> explanation</code><code> = <a href="Expl/index.html#type-t">Expl.t</a></code></dt></dl><section><header><h4 id="accessors"><a href="#accessors" class="anchor"></a>Accessors</h4></header><dl><dt class="spec value" id="val-term_state"><a href="#val-term_state" class="anchor"></a><code><span class="keyword">val</span> term_state : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-term_state">term_state</a></code></dt><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-node">node</a> <span>&#45;&gt;</span> <a href="index.html#type-repr">repr</a></code></dt><dd><p>Current representative</p></dd></dl><dl><dt class="spec value" id="val-add_term"><a href="#val-add_term" class="anchor"></a><code><span class="keyword">val</span> add_term : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-node">node</a></code></dt><dd><p>Add the term to the congruence closure, if not present already. Will be backtracked.</p></dd></dl><dl><dt class="spec value" id="val-mem_term"><a href="#val-mem_term" class="anchor"></a><code><span class="keyword">val</span> mem_term : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns <code>true</code> if the term is explicitly present in the congruence closure</p></dd></dl></section><section><header><h4 id="events"><a href="#events" class="anchor"></a>Events</h4><p>Events triggered by the congruence closure, to which other plugins can subscribe.</p></header><dl><dt class="spec type" id="type-ev_on_pre_merge"><a href="#type-ev_on_pre_merge" class="anchor"></a><code><span class="keyword">type</span> ev_on_pre_merge</code><code> = <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="Expl/index.html#type-t">Expl.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ev_on_pre_merge cc acts n1 n2 expl</code> is called right before <code>n1</code> and <code>n2</code> are merged with explanation <code>expl</code>.</p></dd></dl><dl><dt class="spec type" id="type-ev_on_post_merge"><a href="#type-ev_on_post_merge" class="anchor"></a><code><span class="keyword">type</span> ev_on_post_merge</code><code> = <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ev_on_post_merge cc acts n1 n2</code> is called right after <code>n1</code> and <code>n2</code> were merged. <code>find cc n1</code> and <code>find cc n2</code> will return the same node.</p></dd></dl><dl><dt class="spec type" id="type-ev_on_new_term"><a href="#type-ev_on_new_term" class="anchor"></a><code><span class="keyword">type</span> ev_on_new_term</code><code> = <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ev_on_new_term cc n t</code> is called whenever a new term <code>t</code> is added to the congruence closure. Its node is <code>n</code>.</p></dd></dl><dl><dt class="spec type" id="type-ev_on_conflict"><a href="#type-ev_on_conflict" class="anchor"></a><code><span class="keyword">type</span> ev_on_conflict</code><code> = <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>th:bool</span> <span>&#45;&gt;</span> <span><a href="index.html#type-lit">lit</a> list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ev_on_conflict acts ~th c</code> is called when the congruence closure triggers a conflict by asserting the tautology <code>c</code>.</p><dl><dt>parameter th</dt><dd><p>true if the explanation for this conflict involves at least one &quot;theory&quot; explanation; i.e. some of the equations participating in the conflict are purely syntactic theories like injectivity of constructors.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-ev_on_propagate"><a href="#type-ev_on_propagate" class="anchor"></a><code><span class="keyword">type</span> ev_on_propagate</code><code> = <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span><a href="index.html#type-lit">lit</a> list</span> * <a href="P/index.html#type-t">P.t</a>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ev_on_propagate cc lit reason</code> is called whenever <code>reason() =&gt; lit</code> is a propagated lemma. See <a href="../../../../../../../sidekick/Sidekick_core/module-type-CC_ACTIONS/index.html#val-propagate"><code>Sidekick_core.CC_ACTIONS.propagate</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-ev_on_is_subterm"><a href="#type-ev_on_is_subterm" class="anchor"></a><code><span class="keyword">type</span> ev_on_is_subterm</code><code> = <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>ev_on_is_subterm n t</code> is called when <code>n</code> is a subterm of another node for the first time. <code>t</code> is the term corresponding to the node <code>n</code>. This can be useful for theory combination.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>?&#8288;stat:<a href="../../../../../../../sidekick/Sidekick_util/Stat/index.html#type-t">Sidekick_util.Stat.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;on_pre_merge:<span><a href="index.html#type-ev_on_pre_merge">ev_on_pre_merge</a> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;on_post_merge:<span><a href="index.html#type-ev_on_post_merge">ev_on_post_merge</a> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;on_new_term:<span><a href="index.html#type-ev_on_new_term">ev_on_new_term</a> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;on_conflict:<span><a href="index.html#type-ev_on_conflict">ev_on_conflict</a> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;on_propagate:<span><a href="index.html#type-ev_on_propagate">ev_on_propagate</a> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;on_is_subterm:<span><a href="index.html#type-ev_on_is_subterm">ev_on_is_subterm</a> list</span></span> <span>&#45;&gt;</span> <span>?&#8288;size:<span>[ `Small <span>| `Big</span> ]</span></span> <span>&#45;&gt;</span> <a href="index.html#type-term_state">term_state</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a new congruence closure.</p><dl><dt>parameter term_state</dt><dd><p>used to be able to create new terms. All terms interacting with this congruence closure must belong in this term state as well.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-allocate_bitfield"><a href="#val-allocate_bitfield" class="anchor"></a><code><span class="keyword">val</span> allocate_bitfield : <span>descr:string</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-bitfield">N.bitfield</a></code></dt><dd><p>Allocate a new bitfield for the nodes. See <a href="N/index.html#type-bitfield"><code>N.bitfield</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-set_bitfield"><a href="#val-set_bitfield" class="anchor"></a><code><span class="keyword">val</span> set_bitfield : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-bitfield">N.bitfield</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Set the bitfield for the node. This will be backtracked. See <a href="N/index.html#type-bitfield"><code>N.bitfield</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-on_pre_merge"><a href="#val-on_pre_merge" class="anchor"></a><code><span class="keyword">val</span> on_pre_merge : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ev_on_pre_merge">ev_on_pre_merge</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a function to be called when two classes are merged</p></dd></dl><dl><dt class="spec value" id="val-on_post_merge"><a href="#val-on_post_merge" class="anchor"></a><code><span class="keyword">val</span> on_post_merge : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ev_on_post_merge">ev_on_post_merge</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a function to be called when two classes are merged</p></dd></dl><dl><dt class="spec value" id="val-on_new_term"><a href="#val-on_new_term" class="anchor"></a><code><span class="keyword">val</span> on_new_term : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ev_on_new_term">ev_on_new_term</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a function to be called when a new node is created</p></dd></dl><dl><dt class="spec value" id="val-on_conflict"><a href="#val-on_conflict" class="anchor"></a><code><span class="keyword">val</span> on_conflict : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ev_on_conflict">ev_on_conflict</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Called when the congruence closure finds a conflict</p></dd></dl><dl><dt class="spec value" id="val-on_propagate"><a href="#val-on_propagate" class="anchor"></a><code><span class="keyword">val</span> on_propagate : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ev_on_propagate">ev_on_propagate</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Called when the congruence closure propagates a literal</p></dd></dl><dl><dt class="spec value" id="val-on_is_subterm"><a href="#val-on_is_subterm" class="anchor"></a><code><span class="keyword">val</span> on_is_subterm : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-ev_on_is_subterm">ev_on_is_subterm</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Called on terms that are subterms of function symbols</p></dd></dl><dl><dt class="spec value" id="val-set_as_lit"><a href="#val-set_as_lit" class="anchor"></a><code><span class="keyword">val</span> set_as_lit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>map the given node to a literal.</p></dd></dl><dl><dt class="spec value" id="val-find_t"><a href="#val-find_t" class="anchor"></a><code><span class="keyword">val</span> find_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-repr">repr</a></code></dt><dd><p>Current representative of the term.</p><dl><dt>raises Not_found</dt><dd><p>if the term is not already <code>add</code>-ed.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-add_seq"><a href="#val-add_seq" class="anchor"></a><code><span class="keyword">val</span> add_seq : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-term">term</a> Iter.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add a sequence of terms to the congruence closure</p></dd></dl><dl><dt class="spec value" id="val-all_classes"><a href="#val-all_classes" class="anchor"></a><code><span class="keyword">val</span> all_classes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-repr">repr</a> Iter.t</span></code></dt><dd><p>All current classes. This is costly, only use if there is no other solution</p></dd></dl><dl><dt class="spec value" id="val-assert_lit"><a href="#val-assert_lit" class="anchor"></a><code><span class="keyword">val</span> assert_lit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-lit">lit</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Given a literal, assume it in the congruence closure and propagate its consequences. Will be backtracked.</p><p>Useful for the theory combination or the SAT solver's functor</p></dd></dl><dl><dt class="spec value" id="val-assert_lits"><a href="#val-assert_lits" class="anchor"></a><code><span class="keyword">val</span> assert_lits : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-lit">lit</a> Iter.t</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Addition of many literals</p></dd></dl><dl><dt class="spec value" id="val-explain_eq"><a href="#val-explain_eq" class="anchor"></a><code><span class="keyword">val</span> explain_eq : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-lit">lit</a> list</span></code></dt><dd><p>Explain why the two nodes are equal. Fails if they are not, in an unspecified way</p></dd></dl><dl><dt class="spec value" id="val-raise_conflict_from_expl"><a href="#val-raise_conflict_from_expl" class="anchor"></a><code><span class="keyword">val</span> raise_conflict_from_expl : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> <a href="Expl/index.html#type-t">Expl.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Raise a conflict with the given explanation it must be a theory tautology that <code>expl ==&gt; absurd</code>. To be used in theories.</p></dd></dl><dl><dt class="spec value" id="val-n_true"><a href="#val-n_true" class="anchor"></a><code><span class="keyword">val</span> n_true : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a></code></dt><dd><p>Node for <code>true</code></p></dd></dl><dl><dt class="spec value" id="val-n_false"><a href="#val-n_false" class="anchor"></a><code><span class="keyword">val</span> n_false : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a></code></dt><dd><p>Node for <code>false</code></p></dd></dl><dl><dt class="spec value" id="val-n_bool"><a href="#val-n_bool" class="anchor"></a><code><span class="keyword">val</span> n_bool : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a></code></dt><dd><p>Node for either true or false</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="N/index.html#type-t">N.t</a> <span>&#45;&gt;</span> <a href="Expl/index.html#type-t">Expl.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Merge these two nodes given this explanation. It must be a theory tautology that <code>expl ==&gt; n1 = n2</code>. To be used in theories.</p></dd></dl><dl><dt class="spec value" id="val-merge_t"><a href="#val-merge_t" class="anchor"></a><code><span class="keyword">val</span> merge_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="index.html#type-term">term</a> <span>&#45;&gt;</span> <a href="Expl/index.html#type-t">Expl.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Shortcut for adding + merging</p></dd></dl><dl><dt class="spec value" id="val-check"><a href="#val-check" class="anchor"></a><code><span class="keyword">val</span> check : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-actions">actions</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Perform all pending operations done via <code>assert_eq</code>, <a href="index.html#val-assert_lit"><code>assert_lit</code></a>, etc. Will use the <a href="index.html#type-actions"><code>actions</code></a> to propagate literals, declare conflicts, etc.</p></dd></dl><dl><dt class="spec value" id="val-new_merges"><a href="#val-new_merges" class="anchor"></a><code><span class="keyword">val</span> new_merges : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Called after <a href="index.html#val-check"><code>check</code></a>, returns <code>true</code> if some pairs of classes were merged.</p></dd></dl><dl><dt class="spec value" id="val-push_level"><a href="#val-push_level" class="anchor"></a><code><span class="keyword">val</span> push_level : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Push backtracking level</p></dd></dl><dl><dt class="spec value" id="val-pop_levels"><a href="#val-pop_levels" class="anchor"></a><code><span class="keyword">val</span> pop_levels : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Restore to state <code>n</code> calls to <code>push_level</code> earlier. Used during backtracking.</p></dd></dl><dl><dt class="spec value" id="val-get_model"><a href="#val-get_model" class="anchor"></a><code><span class="keyword">val</span> get_model : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><a href="N/index.html#type-t">N.t</a> Iter.t</span> Iter.t</span></code></dt><dd><p>get all the equivalence classes so they can be merged in the model</p></dd></dl></section></div></body></html>